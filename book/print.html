<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Wrapper for ArrayFire HPC Library</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="Coal">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "Coal";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><a href="vectorization.html"><strong aria-hidden="true">2.</strong> Introduction to Vectorization</a></li><li><a href="array_and_matrix_manipulation.html"><strong aria-hidden="true">3.</strong> Array and Matrix Manipulation</a></li><li><a href="indexing.html"><strong aria-hidden="true">4.</strong> Indexing</a></li><li><a href="configuring_arrayfire_environment.html"><strong aria-hidden="true">5.</strong> Configuring ArrayFire Runtime Environment</a></li><li><a href="cuda-interop.html"><strong aria-hidden="true">6.</strong> Interoperability with CUDA</a></li><li><a href="opencl-interop.html"><strong aria-hidden="true">7.</strong> Interoperability with OpenCL</a></li><li><a href="multi-threading.html"><strong aria-hidden="true">8.</strong> Multhi-Threading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust Wrapper for ArrayFire HPC Library</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>ArrayFire is a high performance software library for parallel computing with an easy-to-use API.
ArrayFire abstracts away much of the details of programming parallel architectures by providing
a high-level container object, the <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a>, that represents data stored on a CPU, GPU, FPGA,
or other type of accelerator. This abstraction permits developers to write massively parallel
applications in a high-level language where they need not be concerned about low-level optimizations
that are frequently required to achieve high throughput on most parallel architectures.</p>
<h2><a class="header" href="#supported-data-types" id="supported-data-types">Supported data types</a></h2>
<p>ArrayFire provides one generic container object, the <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a> on which functions and mathematical
operations are performed. The <code>Array</code> can represent one of many different <a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">basic data types</a>:</p>
<ul>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">F32</a> real single-precision (<code>float</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">C32</a> complex single-precision (<code>cfloat</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">F64</a> real double-precision (<code>double</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">C64</a> complex double-precision (<code>cdouble</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">B8 </a> 8-bit boolean values (<code>bool</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">S32</a> 32-bit signed integer (<code>int</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">U32</a> 32-bit unsigned integer (<code>unsigned</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">U8 </a> 8-bit unsigned values (<code>unsigned char</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">S64</a> 64-bit signed integer (<code>intl</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">U64</a> 64-bit unsigned integer (<code>uintl</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">S16</a> 16-bit signed integer (<code>short</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">U16</a> 16-bit unsigned integer (<code>unsigned short</code>)</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">F16</a> 16-bit floating point number (<a href="https://crates.io/crates/half"><code>half::f16</code></a>)</li>
</ul>
<p>Most of these data types are supported on all modern GPUs; however, some older devices may lack
support for double precision arrays. In this case, a runtime error will be generated when the array
is constructed. </p>
<p>If not specified, <code>Array</code>s are created as single precision floating point numbers (<a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">F32</a>).</p>
<h2><a class="header" href="#creating-and-populating-an-array" id="creating-and-populating-an-array">Creating and populating an Array</a></h2>
<p>ArrayFire <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a>'s represent memory stored on the device. As such, creation and population of
an array will consume memory on the device which cannot freed until the <code>array</code> object goes out of
scope. As device memory allocation can be expensive, ArrayFire also includes a memory manager which
will re-use device memory whenever possible.</p>
<p>Arrays can be created using one of the <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.new_empty">array constructors</a>. Below we show how to create 1D, 2D,
and 3D arrays with uninitialized values:</p>
<pre><code class="language-rust noplaypen">let garbageVals = Array::new_empty(Dim4::new(&amp;[3, 1, 1, 1]), DType::F32);
</code></pre>
<p>However, uninitialized memory is likely not useful in your application. ArrayFire provides several
convenient functions for creating arrays that contain pre-populated values including constants,
uniform random numbers, uniform normally distributed numbers, and the identity matrix:</p>
<pre><code class="language-rust noplaypen">// Create an array filled with constant value of 2.0 of type floating point
// The type of Array is infered from the type of the constant argument
let cnst = constant(2.0f32, Dim4::new(&amp;[5, 5, 1, 1]));
print(&amp;cnst);
</code></pre>
<pre><code class="language-rust noplaypen">println!(&quot;Create a 5-by-3 matrix of random floats on the GPU&quot;);
let dims = Dim4::new(&amp;[5, 3, 1, 1]);
let a = randu::&lt;f32&gt;(dims);
print(&amp;a);
</code></pre>
<p>As stated above, the default data type for arrays is <a href="http://arrayfire.org/arrayfire-rust/arrayfire/enum.DType.html">F32</a>(32-bit floating point number) unless
specified otherwise.</p>
<p>ArrayFire <code>Array</code>s may also be populated from data found on the host. For example:</p>
<pre><code class="language-rust noplaypen">let values: [u32; 3] = [1u32, 2, 3];
let indices = Array::new(&amp;values, Dim4::new(&amp;[3, 1, 1, 1]));
print(&amp;indices);
</code></pre>
<h2><a class="header" href="#properties-of-an-array" id="properties-of-an-array">Properties of an Array</a></h2>
<p>ArrayFire provides several functions to determine various aspects of arrays. This includes
functions to print the contents, query dimensions, and determine various other aspects of arrays.</p>
<p>The <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.print.html">print</a> function can be used to print arrays that have already been generated or any
expression involving arrays:</p>
<pre><code class="language-rust noplaypen">let values: [f32; 3] = [1.0, 2.0, 3.0];
let indices = Array::new(&amp;values, Dim4::new(&amp;[3, 1, 1, 1]));
print(&amp;indices);
</code></pre>
<p>The dimensions of an array may be determined using either a <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Dim4.html">Dim4</a> object or by accessing the
dimensions directly using the <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Dim4.html#method.get">Dim4::get</a> and <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Dim4.html#method.ndims">Dim4::numdims</a> functions:</p>
<pre><code class="language-rust noplaypen">let values: [f32; 3] = [1.0, 2.0, 3.0];
let dims: Dim4 = Dim4::new(&amp;[3, 1, 1, 1]);
let indices = Array::new(&amp;values, dims);
println!(&quot;Dims {:?} with dimensions {}&quot;, dims.get(), dims.ndims());
</code></pre>
<p>In addition to dimensions, arrays also carry several properties including methods to determine the
underlying type and size (in bytes). You can even determine whether the array is empty, real/complex,
a row/column, or a scalar or a vector. For further information on these capabilities, we suggest you
consult the full documentation on the <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a>.</p>
<h2><a class="header" href="#writing-math-expressions-using-arrayfire" id="writing-math-expressions-using-arrayfire">Writing math expressions using ArrayFire</a></h2>
<p>ArrayFire features an intelligent Just-In-Time (JIT) compilation engine that converts expressions
using arrays into the smallest number of CUDA/OpenCL kernels. For most operations on Arrays,
ArrayFire functions like a vector library. That means that an element-wise operation, like
<code>c[i] = a[i] + b[i]</code> in C, would be written more concisely without indexing, like <code>c = a + b</code>. When
there are multiple expressions involving arrays, ArrayFire's JIT engine will merge them together.
his &quot;kernel fusion&quot; technology not only decreases the number of kernel calls, but, more importantly, avoids extraneous global memory operations.</p>
<p>Our JIT functionality extends across C API boundary and only ends when a non-JIT function is
encountered or a synchronization operation is explicitly called by the code.</p>
<p>ArrayFire provides hundreds of functions for element-wise operations. All of the standard operators
(e.g. +,-,*,/) are supported as are most transcendental functions (sin, cos, log, sqrt, etc.). Here are a few examples:</p>
<pre><code class="language-rust noplaypen">let num_rows: u64 = 5;
let num_cols: u64 = 3;
let dims = Dim4::new(&amp;[num_rows, num_cols, 1, 1]);
let a = randu::&lt;f32&gt;(dims);
let b = randu::&lt;f32&gt;(dims);
print(&amp;a);
print(&amp;b);
let c = a + b;
print(&amp;c);

//Example of *Assign traits
let mut d = randu::&lt;f32&gt;(dims);
let e     = constant(1f32, dims);
d += e;
print(&amp;d);
</code></pre>
<h2><a class="header" href="#indexing" id="indexing">Indexing</a></h2>
<p>Like all functions in ArrayFire, indexing is also executed in parallel on the OpenCL/CUDA device. To
index <code>Array</code>s you may use one or a combination of the following functions:</p>
<ul>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Seq.html">Seq</a> representing a linear sequence</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Seq.html">Seq::Default()</a> representing the entire dimension</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.row.html">row(&amp;Array, i)</a> or <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.col.html">col(&amp;Array, i)</a> specifying a single row/column</li>
<li><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.rows.html">rows(&amp;Array, first,last)</a> or <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.cols.html">cols(&amp;Array, first,last)</a> specifying a span of rows or columns</li>
</ul>
<p>Please see the <a href="./indexing.html">indexing page</a> for several examples of how to use these functions.</p>
<h2><a class="header" href="#access-to-array-memory-on-the-host" id="access-to-array-memory-on-the-host">Access to Array memory on the host</a></h2>
<p>Memory in <code>af::Array</code>s may be accessed using the <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Dim4.html#method.host">Array::host()</a> method. The <code>host</code> function
<em>copies</em> the data from the device and makes it available in a standard slice or similar container on
the host. As such, it is up to the developer to manage any memory returned by <code>host</code>.</p>
<!--
Lastly, if you want only the first value from an `af::array` you can use
get it using the [scalar()](\ref af::array::scalar) function:
```rust,noplaypen
```
-->
<h2><a class="header" href="#bitwise-operators" id="bitwise-operators">Bitwise operators</a></h2>
<p>In addition to supporting standard mathematical functions, Arrays that contain integer data types
also support bitwise operators including and, or, and shift etc. Operator traits for Array as well
as separate functions are also defined to support various use cases.</p>
<pre><code class="language-rust noplaypen">let dims = Dim4::new(&amp;[5, 3, 1, 1]);
let a = randu::&lt;bool&gt;(dims);
let b = randu::&lt;bool&gt;(dims);

print(&amp;a);
print(&amp;b);

let c = &amp;a | &amp;b; //Borrowing to avoid move of a and b, a | b is also valid
let d = bitand(&amp;a, &amp;b, false);

print(&amp;c);
print(&amp;d);
</code></pre>
<h2><a class="header" href="#where-to-go-for-help" id="where-to-go-for-help">Where to go for help?</a></h2>
<ul>
<li><a href="https://groups.google.com/forum/#!forum/arrayfire-users">Google Groups</a></li>
<li>ArrayFire Services: <a href="http://arrayfire.com/consulting/">Consulting</a> | <a href="http://arrayfire.com/support/">Support</a> | <a href="http://arrayfire.com/training/">Training</a></li>
<li><a href="http://arrayfire.com/blog/">ArrayFire Blogs</a></li>
<li>Email: <a href="mailto:technical@arrayfire.com">mailto:technical@arrayfire.com</a></li>
</ul>
<h1><a class="header" href="#vectorization" id="vectorization">Vectorization</a></h1>
<p>Programmers and Data Scientists want to take advantage of fast and parallel computational devices.
Writing vectorized code is necessary to get the best performance out of the current generation
parallel hardware and scientific computing software. However, writing vectorized code may not be
immediately intuitive. ArrayFire provides many ways to vectorize a given code segment. In this
chapter, we present several methods to vectorize code using ArrayFire and discuss the benefits and
drawbacks associated with each method.</p>
<h2><a class="header" href="#genericdefault-vectorization" id="genericdefault-vectorization">Generic/Default vectorization</a></h2>
<p>By its very nature, ArrayFire is a vectorized library. Most functions operate on Arrays as a whole
i.e. on all elements in parallel. For example consider the following code:</p>
<pre><code class="language-rust noplaypen">let mut a = af::range(Dim::new(&amp;[10, 1, 1, 1]));  // [0,  9]
a = a + 1;                                        // [1, 10]
</code></pre>
<p>This code will result in a single kernel that operates on all 10 elements of <code>a</code> in  parallel.</p>
<p>A small subset of such vectorized ArrayFire functions are given below for quick reference:</p>
<table><thead><tr><th>Operator Category</th><th>Functions</th></tr></thead><tbody>
<tr><td>Arithmetic operations</td><td>+, -, *, /, %, &gt;&gt;, &lt;&lt;</td></tr>
<tr><td>Logical operations</td><td>&amp;&amp;, ||, &lt;, &gt;, ==, != etc.</td></tr>
<tr><td>Numeric functions</td><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.abs.html">abs</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.floor.html">floor</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.round.html">round</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.min.html">min</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.max.html">max</a>, etc.</td></tr>
<tr><td>Complex operations</td><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.real.html">real</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.imag.html">imag</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.conjg.html">conjg</a>, etc.</td></tr>
<tr><td>Exponential and logarithmic fns</td><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.exp.html">exp</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.log.html">log</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.expm1.html">expm1</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.log1p.html">log1p</a>, etc.</td></tr>
<tr><td>Trigonometric functions</td><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.sin.html">sin</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.cos.html">cos</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.tan.html">tan</a>, etc.</td></tr>
<tr><td>Hyperbolic functions</td><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.sinh.html">sinh</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.cosh.html">cosh</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.tanh.html">tanh</a>, etc.</td></tr>
</tbody></table>
<p>In addition to element-wise operations, many other functions are also vectorized in ArrayFire.</p>
<p>Notice that even functions that perform some form of aggregation (e.g. <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.sum.html">sum</a> or <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.cos.html">min</a>),
signal processing (like <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.convolve1.html">convolve</a>), and image processing functions (i.e. <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.rotate.html">rotate</a> etc.)</p>
<ul>
<li>all support vectorization on  different columns or images.</li>
</ul>
<p>For example, if we have <code>NUM</code> images of size <code>WIDTH</code>x<code>HEIGHT</code>, one could convolve each image in a
vector fashion as follows:</p>
<pre><code class="language-rust noplaypen">let g_coef: [f32, 9] = { 1, 2, 1, 2, 4, 2, 1, 2, 1 };

let f = Array::new(g_coef, Dim4::new(&amp;[3, 3, 1, 1]));
let filter = f * 1.0f32/16;

let signal = randu(WIDTH, HEIGHT, NUM);
let conv   = convolve2(signal, filter, ConvMode::DEFAULT, ConvDomain::AUTO);
</code></pre>
<p>Similarly, one can rotate 100 images by 45 degrees in a single call using code like the following:</p>
<pre><code class="language-rust noplaypen">// Construct an array of 100 WIDTH x HEIGHT images of random numbers
let imgs = randu(WIDTH, HEIGHT, 100);

// Rotate all of the images in a single command
let rot_imgs = rotate(imgs, 45.0, False, InterpType::LINEAR);
</code></pre>
<p>Although <em>most</em> functions in ArrayFire do support vectorization, some do not. Most notably, all
linear algebra functions. Even though they are not vectorized linear algebra operations, they still
execute in parallel on your hardware.</p>
<p>Using the built in vectorized operations should be the first and preferred method of vectorizing any
code written with ArrayFire.</p>
<h2><a class="header" href="#gfor" id="gfor">GFOR</a></h2>
<p>This construct is similar to gfor loop from C++ API of ArrayFire. It has not been implemented in
rust wrapper. This section will be updated once the feature has been added to the crate.</p>
<h2><a class="header" href="#batch_func" id="batch_func">batch_func</a></h2>
<p>This another pending feature that is similar to our C++ API of <a href="http://arrayfire.org/docs/namespaceaf.htm#aa0eb9e160f5be4b95234543e5c47934b">batchFunc()</a></p>
<h1><a class="header" href="#array-and-matrix-manipulation" id="array-and-matrix-manipulation">Array and Matrix Manipulation</a></h1>
<p>ArrayFire provides several different methods for manipulating arrays and matrices. The functionality
includes:</p>
<ul>
<li><a href="array_and_matrix_manipulation.html#moddims">moddims()</a> - change the dimensions of an array without changing the data</li>
<li><a href="array_and_matrix_manipulation.html#flat">flat()</a> - flatten an array to one dimension</li>
<li><a href="array_and_matrix_manipulation.html#flip">flip()</a> - flip an array along a dimension</li>
<li><a href="array_and_matrix_manipulation.html#join">join()</a> - join up to 4 arrays</li>
<li><a href="array_and_matrix_manipulation.html#reorder">reorder()</a> - changes the dimension order within the array</li>
<li><a href="array_and_matrix_manipulation.html#shift">shift()</a> - shifts data along a dimension</li>
<li><a href="array_and_matrix_manipulation.html#tile">tile()</a> - repeats an array along a dimension</li>
<li><a href="array_and_matrix_manipulation.html#transpose">transpose()</a> - performs a matrix transpose</li>
</ul>
<p>Below we provide several examples of these functions and their use.</p>
<h3><a class="header" href="#moddims" id="moddims">moddims()</a></h3>
<p>The <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.moddims.html">moddims</a> function changes the dimensions of an array without changing its data or order.
Note that this function modifies only the <em>metadata</em> associated with the array. It does not modify
the content of the array. Here is an example of moddims() converting an 8x1 array into a 2x4 and
then back to a 8x1:</p>
<pre><code class="language-rust noplaypen">a [8 1 1 1]
    1.0000
    2.0000
    1.0000
    2.0000
    1.0000
    2.0000
    1.0000
    2.0000

let new_dims = Dim4::new(&amp;[2, 4, 1, 1]);
moddims(&amp;a, new_dims)
[2 4 1 1]
    1.0000     1.0000     1.0000     1.0000
    2.0000     2.0000     2.0000     2.0000

let out = moddims(&amp;a, a.elements(), 1, 1, 1);
[8 1 1 1]
    1.0000
    2.0000
    1.0000
    2.0000
    1.0000
    2.0000
    1.0000
    2.0000
</code></pre>
<h3><a class="header" href="#flat" id="flat">flat()</a></h3>
<p>The <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.flat.html">flat</a> function flattens an array to one dimension:</p>
<pre><code>a [3 3 1 1]
    1.0000     4.0000     7.0000
    2.0000     5.0000     8.0000
    3.0000     6.0000     9.0000

flat(&amp;a)
[9 1 1 1]
    1.0000
    2.0000
    3.0000
    4.0000
    5.0000
    6.0000
    7.0000
    8.0000
    9.0000
</code></pre>
<h3><a class="header" href="#flip" id="flip">flip()</a></h3>
<p>The <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.flip.html">flip</a> function flips the contents of an array along a chosen dimension. In the example
below, we show the 5x2 array flipped along the zeroth (i.e. within a column) and first (e.g.
across rows) axes:</p>
<pre><code class="language-rust noplaypen">a [5 2 1 1]
    1.0000     6.0000
    2.0000     7.0000
    3.0000     8.0000
    4.0000     9.0000
    5.0000    10.0000

flip(a, 0) [5 2 1 1]
    5.0000    10.0000
    4.0000     9.0000
    3.0000     8.0000
    2.0000     7.0000
    1.0000     6.0000

flip(a, 1) [5 2 1 1]
    6.0000     1.0000
    7.0000     2.0000
    8.0000     3.0000
    9.0000     4.0000
   10.0000     5.0000
</code></pre>
<h3><a class="header" href="#join" id="join">join()</a></h3>
<p>The <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.join.html">join</a>, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.join_many.html">join_many</a> functions can be used to join arrays along a specific dimension.</p>
<p>Here is an example of how to use join an array to itself:</p>
<pre><code class="language-rust noplaypen">a [5 1 1 1]
    1.0000
    2.0000
    3.0000
    4.0000
    5.0000

join(0, a, a) [10 1 1 1]
    1.0000
    2.0000
    3.0000
    4.0000
    5.0000
    1.0000
    2.0000
    3.0000
    4.0000
    5.0000

join(1, a, a) [5 2 1 1]
    1.0000     1.0000
    2.0000     2.0000
    3.0000     3.0000
    4.0000     4.0000
    5.0000     5.0000
</code></pre>
<h3><a class="header" href="#reorder" id="reorder">reorder()</a></h3>
<p>The <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.reorder.html">reorder</a> function modifies the order of data within an array by exchanging data according to
the change in dimensionality. The linear ordering of data within the array is preserved.</p>
<pre><code class="language-rust noplaypen">a [2 2 3 1]
    1.0000     3.0000
    2.0000     4.0000

    1.0000     3.0000
    2.0000     4.0000

    1.0000     3.0000
    2.0000     4.0000


reorder(&amp;a, 1, 0, 2)
[2 2 3 1]  //equivalent to a transpose
    1.0000     2.0000
    3.0000     4.0000

    1.0000     2.0000
    3.0000     4.0000

    1.0000     2.0000
    3.0000     4.0000


reorder(&amp;a, 2, 0, 1)
[3 2 2 1]
    1.0000     2.0000
    1.0000     2.0000
    1.0000     2.0000

    3.0000     4.0000
    3.0000     4.0000
    3.0000     4.0000
</code></pre>
<h3><a class="header" href="#shift" id="shift">shift()</a></h3>
<p>The <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.shift.html">shift</a> function shifts data in a circular buffer fashion along a chosen dimension. Consider
the following example:</p>
<pre><code class="language-rust noplaypen">a [3 5 1 1]
    0.0000     0.0000     0.0000     0.0000     0.0000
    3.0000     4.0000     5.0000     1.0000     2.0000
    3.0000     4.0000     5.0000     1.0000     2.0000

shift(&amp;a, 0, 2 )
[3 5 1 1]
    0.0000     0.0000     0.0000     0.0000     0.0000
    1.0000     2.0000     3.0000     4.0000     5.0000
    1.0000     2.0000     3.0000     4.0000     5.0000

shift(&amp;a, -1, 2 )
[3 5 1 1]
    1.0000     2.0000     3.0000     4.0000     5.0000
    1.0000     2.0000     3.0000     4.0000     5.0000
    0.0000     0.0000     0.0000     0.0000     0.0000
</code></pre>
<h3><a class="header" href="#tile" id="tile">tile()</a></h3>
<p>The <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.tile.html">tile</a> function repeats an array along the specified dimension. For example below we show how
to tile an array along the zeroth and first dimensions of an array:</p>
<pre><code class="language-rust noplaypen">a [3 1 1 1]
    1.0000
    2.0000
    3.0000

// Repeat array a twice in the zeroth dimension
tile(&amp;a, 2)
[6 1 1 1]
    1.0000
    2.0000
    3.0000
    1.0000
    2.0000
    3.0000

// Repeat array a twice along both the zeroth and first dimensions
tile(&amp;a, 2, 2)
[6 2 1 1]
    1.0000     1.0000
    2.0000     2.0000
    3.0000     3.0000
    1.0000     1.0000
    2.0000     2.0000
    3.0000     3.0000

// Repeat array a twice along the first and three times along the second
// dimension.
let tile_dims = Dim4::new(&amp;[1, 2, 3, 1]);
tile(a, tile_dims) [3 2 3 1]
    1.0000     1.0000
    2.0000     2.0000
    3.0000     3.0000

    1.0000     1.0000
    2.0000     2.0000
    3.0000     3.0000

    1.0000     1.0000
    2.0000     2.0000
    3.0000     3.0000
</code></pre>
<h3><a class="header" href="#transpose" id="transpose">transpose()</a></h3>
<p>The <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.transpose.html">transpose</a> function performs a standard matrix transpose. The input array must have the
dimensions of a 2D-matrix.</p>
<pre><code class="language-rust noplaypen">a [3 3 1 1]
    1.0000     3.0000     3.0000
    2.0000     1.0000     3.0000
    2.0000     2.0000     1.0000

transpose(&amp;a, False) //Second parameter to be used for conjugate transpose
[3 3 1 1]
    1.0000     2.0000     2.0000
    3.0000     1.0000     2.0000
    3.0000     3.0000     1.0000
</code></pre>
<h3><a class="header" href="#combining-functions-to-enumerate-grid-coordinates" id="combining-functions-to-enumerate-grid-coordinates">Combining functions to enumerate grid coordinates</a></h3>
<p>By using a combination of the functions, one can quickly code complex manipulation patterns with
a few lines of code. For example, consider generating (x,y) coordinates for a grid where each axis
goes from 1 to n. Instead of using several loops to populate our arrays we can just use a small
combination of the above functions.</p>
<pre><code class="language-rust noplaypen">let a      = iota::&lt;u32&gt;(Dim4::new(&amp;[3, 1, 1, 1]),
                         Dim4::new(&amp;[1, 3, 1, 1]));
let b      = transpose(&amp;a, false);
let coords = join(1, &amp;flat(&amp;a), &amp;flat(&amp;b));
print(&amp;coords);
</code></pre>
<p>The output for a <code>[3 3 1 1]</code> matrix will be the following.</p>
<pre><code class="language-rust noplaypen">[9 2 1 1]
         0          0
         1          0
         2          0
         0          1
         1          1
         2          1
         0          2
         1          2
         2          2
</code></pre>
<h1><a class="header" href="#indexing-1" id="indexing-1">Indexing</a></h1>
<p>Indexing in ArrayFire is a powerful but easy to abuse feature. This feature allows you to reference
or copy subsections of a larger array and perform operations on only a subset of elements.</p>
<p>This chapter is split into the following sections:</p>
<ul>
<li><a href="indexing.html#using-seq-objects">Index an Array using Seq Objects</a>
<ul>
<li><a href="indexing.html#create-a-view-of-an-existing-array">Create a view of an existing Array</a></li>
<li><a href="indexing.html#modify-a-sub-region-of-an-existing-array">Modify a sub region of an existing Array</a></li>
</ul>
</li>
<li><a href="indexing.html#using-array-and-seq-combination">Using Array and Seq combination</a>
<ul>
<li><a href="indexing.html#create-a-view-of-an-existing-array">Create a view of an existing Array</a></li>
<li><a href="indexing.html#modify-a-sub-region-of-an-existing-array">Modify a sub region of an existing Array</a></li>
</ul>
</li>
<li><a href="indexing.html#extract-or-set-rowscolumns-of-an-array">Extract or Set rows/columns of an Array</a></li>
<li><a href="indexing.html#negative-indices">Negative Indices</a></li>
</ul>
<p><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Indexer.html">Indexer</a> structure is the key element used in Rust wrapper of ArrayFire for creating references
to existing Arrays. The above sections illustrate how it can be used in conjunction with <code>Seq</code>
and/or <code>Array</code>. Apart from that, each section also showcases a macro based equivalent
code(if one exists) that is more terse in syntax but offers the same functionality.</p>
<h2><a class="header" href="#using-seq-objects" id="using-seq-objects">Using Seq objects</a></h2>
<h3><a class="header" href="#create-a-view-of-an-existing-array" id="create-a-view-of-an-existing-array">Create a view of an existing Array</a></h3>
<p>We will Sequences and the function <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.index.html">index</a> in this approach. </p>
<pre><code class="language-rust noplaypen">        let dims = Dim4::new(&amp;[5, 5, 1, 1]);
        let a = randu::&lt;f32&gt;(dims);
        //af_print!(&quot;a&quot;, a);
        //a
        //[5 5 1 1]
        //    0.3990     0.5160     0.8831     0.9107     0.6688
        //    0.6720     0.3932     0.0621     0.9159     0.8434
        //    0.5339     0.2706     0.7089     0.0231     0.1328
        //    0.1386     0.9455     0.9434     0.2330     0.2657
        //    0.7353     0.1587     0.1227     0.2220     0.2299

        // Index array using sequences
        let seqs = &amp;[Seq::new(1u32, 3, 1), Seq::default()];
        let _sub = index(&amp;a, seqs);
        //af_print!(&quot;a(seq(1,3,1), span)&quot;, sub);
        // [3 5 1 1]
        //     0.6720     0.3932     0.0621     0.9159     0.8434
        //     0.5339     0.2706     0.7089     0.0231     0.1328
        //     0.1386     0.9455     0.9434     0.2330     0.2657
</code></pre>
<p>However, the same above code can be condensed into a much terse syntax with the help of <a href="http://arrayfire.org/arrayfire-rust/arrayfire/macro.view.html">view</a>
macro. Take a look at the following two approaches using view macro.</p>
<pre><code class="language-rust noplaypen">        let dims = dim4!(5, 5, 1, 1);
        let a = randu::&lt;f32&gt;(dims);
        let first3 = seq!(1:3:1);
        let allindim2 = seq!();
        let _sub = view!(a[first3, allindim2]);
</code></pre>
<div style="text-align: center"> OR </div>
<pre><code class="language-rust noplaypen">        let a = randu::&lt;f32&gt;(dim4!(5, 5));
        let _sub = view!(a[1:3:1, 1:1:0]); // 1:1:0 means all elements along axis

</code></pre>
<h3><a class="header" href="#modify-a-sub-region-of-an-existing-array" id="modify-a-sub-region-of-an-existing-array">Modify a sub region of an existing Array</a></h3>
<p>Let us take a look at an example where a portion of an existing Array will be set to with another
Array. We will an constant value Array and the function <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.assign_seq.html">assign_seq</a> in the below example.</p>
<pre><code class="language-rust noplaypen">        let mut a = constant(2.0 as f32, dim4!(5, 3));
        //print(&amp;a);
        // 2.0 2.0 2.0
        // 2.0 2.0 2.0
        // 2.0 2.0 2.0
        // 2.0 2.0 2.0
        // 2.0 2.0 2.0

        let b = constant(1.0 as f32, dim4!(3, 3));
        let seqs = [seq!(1:3:1), seq!()];
        assign_seq(&amp;mut a, &amp;seqs, &amp;b);
        //print(&amp;a);
        // 2.0 2.0 2.0
        // 1.0 1.0 1.0
        // 1.0 1.0 1.0
        // 1.0 1.0 1.0
        // 2.0 2.0 2.0
</code></pre>
<p>A much terser way of doing the same using macro is shown below</p>
<pre><code class="language-rust noplaypen">        let mut a = randu::&lt;f32&gt;(dim4!(5, 5));
        let b = randu::&lt;f32&gt;(dim4!(2, 2));
        eval!(a[1:2:1, 1:2:1] = b);
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Normally you want to avoid accessing individual elements of the array like this for performance reasons.</p>
</blockquote>
<h2><a class="header" href="#using-array-and-seq-combination" id="using-array-and-seq-combination">Using Array and Seq combination</a></h2>
<h3><a class="header" href="#create-a-view-of-an-existing-array-1" id="create-a-view-of-an-existing-array-1">Create a view of an existing Array</a></h3>
<p>To use a combination of Array and Seq objects to index an existing Array, we will need a more
generalized function <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.index_gen.html">index_gen</a>.</p>
<pre><code class="language-rust noplaypen">        let values: [f32; 3] = [1.0, 2.0, 3.0];
        let indices = Array::new(&amp;values, Dim4::new(&amp;[3, 1, 1, 1]));
        let seq4gen = Seq::new(0.0, 2.0, 1.0);
        let a = randu::&lt;f32&gt;(Dim4::new(&amp;[5, 3, 1, 1]));
        // [5 3 1 1]
        //     0.0000     0.2190     0.3835
        //     0.1315     0.0470     0.5194
        //     0.7556     0.6789     0.8310
        //     0.4587     0.6793     0.0346
        //     0.5328     0.9347     0.0535

        let mut idxrs = Indexer::default();
        idxrs.set_index(&amp;indices, 0, None); // 2nd arg is indexing dimension
        idxrs.set_index(&amp;seq4gen, 1, Some(false)); // 3rd arg indicates batch operation

        let _sub2 = index_gen(&amp;a, idxrs);
        //println!(&quot;a(indices, seq(0, 2, 1))&quot;); print(&amp;sub2);
        // [3 3 1 1]
        //     0.1315     0.0470     0.5194
        //     0.7556     0.6789     0.8310
        //     0.4587     0.6793     0.0346
</code></pre>
<p>Similar to how <a href="http://arrayfire.org/arrayfire-rust/arrayfire/macro.view.html">view</a> macro helped with abreviating the syntax when indexing with just
sequences, it can also help when using a combination of Seq and Array.</p>
<pre><code class="language-rust noplaypen">        let values: [f32; 3] = [1.0, 2.0, 3.0];
        let indices = Array::new(&amp;values, Dim4::new(&amp;[3, 1, 1, 1]));
        let seq4gen = seq!(0:2:1);
        let a = randu::&lt;f32&gt;(Dim4::new(&amp;[5, 3, 1, 1]));
        let _sub2 = view!(a[indices, seq4gen]);
</code></pre>
<h3><a class="header" href="#modify-a-sub-region-of-an-existing-array-1" id="modify-a-sub-region-of-an-existing-array-1">Modify a sub region of an existing Array</a></h3>
<p>Set a portion of an existing Array with another Array using a combination of <code>Seq</code> and <code>Array</code>.
We will use <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.assign_gen.html">assign_gen</a> function to do it.</p>
<pre><code class="language-rust noplaypen">       let values: [f32; 3] = [1.0, 2.0, 3.0];
       let indices = Array::new(&amp;values, dim4!(3, 1, 1, 1));
       let seq4gen = seq!(0:2:1);
       let mut a = randu::&lt;f32&gt;(dim4!(5, 3, 1, 1));
       // [5 3 1 1]
       //     0.0000     0.2190     0.3835
       //     0.1315     0.0470     0.5194
       //     0.7556     0.6789     0.8310
       //     0.4587     0.6793     0.0346
       //     0.5328     0.9347     0.0535

       let b = constant(2.0 as f32, dim4!(3, 3, 1, 1));

       let mut idxrs = Indexer::default();
       idxrs.set_index(&amp;indices, 0, None); // 2nd arg is indexing dimension
       idxrs.set_index(&amp;seq4gen, 1, Some(false)); // 3rd arg indicates batch operation

       let _sub2 = assign_gen(&amp;mut a, &amp;idxrs, &amp;b);
       //println!(&quot;a(indices, seq(0, 2, 1))&quot;); print(&amp;sub2);
       // [5 3 1 1]
       //     0.0000     0.2190     0.3835
       //     2.0000     2.0000     2.0000
       //     2.0000     2.0000     2.0000
       //     2.0000     2.0000     2.0000
       //     0.5328     0.9347     0.0535
</code></pre>
<div style="text-align: center"> OR </div>
<pre><code class="language-rust noplaypen">       let values: [f32; 3] = [1.0, 2.0, 3.0];
       let indices = Array::new(&amp;values, dim4!(3));
       let seq4gen = seq!(0:2:1);
       let mut a = randu::&lt;f32&gt;(dim4!(5, 3));

       let b = constant(2.0 as f32, dim4!(3, 3));

       eval!(a[indices, seq4gen] = b);
</code></pre>
<h2><a class="header" href="#extract-or-set-rowscolumns-of-an-array" id="extract-or-set-rowscolumns-of-an-array">Extract or Set rows/columns of an Array</a></h2>
<p>Extract a specific set of rows/coloumns from an existing Array.</p>
<pre><code class="language-rust noplaypen">        let a = randu::&lt;f32&gt;(dim4!(5, 5, 1, 1));
        //print(&amp;a);
        // [5 5 1 1]
        //     0.6010     0.5497     0.1583     0.3636     0.6755
        //     0.0278     0.2864     0.3712     0.4165     0.6105
        //     0.9806     0.3410     0.3543     0.5814     0.5232
        //     0.2126     0.7509     0.6450     0.8962     0.5567
        //     0.0655     0.4105     0.9675     0.3712     0.7896
        let _r = row(&amp;a, 4);
        // [1 5 1 1]
        //     0.0655     0.4105     0.9675     0.3712     0.7896
        let _c = col(&amp;a, 4);
        // [5 1 1 1]
        //     0.6755
        //     0.6105
        //     0.5232
        //     0.5567
        //     0.7896
</code></pre>
<p>You can also use <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.rows.html">rows</a> &amp; <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.cols.html">cols</a> to retrieve a subset of rows or coloumns respectively.</p>
<p>Similarly, <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.set_row.html">set_row</a> &amp; <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.set_rows.html">set_rows</a> can be used to change the values in a particular set of
rows using another Array. <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.set_col.html">set_col</a> &amp; <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.set_cols.html">set_cols</a> has same functionality, except that it is
for coloumns.</p>
<h2><a class="header" href="#negative-indices" id="negative-indices">Negative Indices</a></h2>
<p>Negative indices can also be used to refer elements from the end of a given axis. Negative value for
a row/column/slice will fetch corresponding row/column/slice in reverse order. Given below are some
examples that showcase getting row(s)/col(s) from an existing Array.</p>
<pre><code class="language-rust noplaypen">        let a = randu::&lt;f32&gt;(dim4!(5, 5));
        // [5 5 1 1]
        //     0.6010     0.5497     0.1583     0.3636     0.6755
        //     0.0278     0.2864     0.3712     0.4165     0.6105
        //     0.9806     0.3410     0.3543     0.5814     0.5232
        //     0.2126     0.7509     0.6450     0.8962     0.5567
        //     0.0655     0.4105     0.9675     0.3712     0.7896
        let _r = row(&amp;a, -1);
        // [1 5 1 1]
        //     0.0655     0.4105     0.9675     0.3712     0.7896
        let _c = col(&amp;a, -1);
        // [5 1 1 1]
        //     0.6755
        //     0.6105
        //     0.5232
        //     0.5567
        //     0.7896
</code></pre>
<pre><code class="language-rust noplaypen">        let a = randu::&lt;f32&gt;(dim4!(5, 5));
        // [5 5 1 1]
        //     0.6010     0.5497     0.1583     0.3636     0.6755
        //     0.0278     0.2864     0.3712     0.4165     0.6105
        //     0.9806     0.3410     0.3543     0.5814     0.5232
        //     0.2126     0.7509     0.6450     0.8962     0.5567
        //     0.0655     0.4105     0.9675     0.3712     0.7896
        let _r = rows(&amp;a, -1, -2);
        // [2 5 1 1]
        //     0.2126     0.7509     0.6450     0.8962     0.5567
        //     0.0655     0.4105     0.9675     0.3712     0.7896
        let _c = cols(&amp;a, -1, -3);
        // [5 3 1 1]
        //     0.1583     0.3636     0.6755
        //     0.3712     0.4165     0.6105
        //     0.3543     0.5814     0.5232
        //     0.6450     0.8962     0.5567
        //     0.9675     0.3712     0.7896
</code></pre>
<h1><a class="header" href="#configuring-arrayfire-environment" id="configuring-arrayfire-environment">Configuring Arrayfire Environment</a></h1>
<p>Following are the list of environment and runtime configurations that will help enhance your
experience with ArrayFire.</p>
<h2><a class="header" href="#af_path" id="af_path">AF_PATH</a></h2>
<p>This is the path with ArrayFire gets installed, ie. the includes and libs are present in this
directory. You can use this variable to add include paths and libraries to your projects.</p>
<h2><a class="header" href="#af_print_errors" id="af_print_errors">AF_PRINT_ERRORS</a></h2>
<p>When <code>AF\_PRINT\_ERRORS</code> is set to 1, the exceptions thrown are more verbose and detailed. This
helps in locating the exact failure.</p>
<pre><code>AF_PRINT_ERRORS=1 ./myprogram
</code></pre>
<h2><a class="header" href="#af_cuda_default_device" id="af_cuda_default_device">AF_CUDA_DEFAULT_DEVICE</a></h2>
<p>Use this variable to set the default CUDA device. Valid values for this variable are the device
identifiers shown when <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.info.html">info</a> is run.</p>
<pre><code>AF_CUDA_DEFAULT_DEVICE=1 ./myprogram
</code></pre>
<p>Note: <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.set_device.html">set_device</a> call in the source code will take precedence over this variable.</p>
<h2><a class="header" href="#af_opencl_default_device" id="af_opencl_default_device">AF_OPENCL_DEFAULT_DEVICE</a></h2>
<p>Use this variable to set the default OpenCL device. Valid values for this variable are the device
identifiers shown when <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.info.html">info</a> is run.</p>
<pre><code>AF_OPENCL_DEFAULT_DEVICE=1 ./myprogram
</code></pre>
<p>Note: <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.set_device.html">set_device</a> call in the source code will take precedence over this variable.</p>
<h2><a class="header" href="#af_opencl_default_device_type" id="af_opencl_default_device_type">AF_OPENCL_DEFAULT_DEVICE_TYPE</a></h2>
<p>Use this variable to set the default OpenCL device type. Valid values for this variable are: CPU,
GPU, ACC (Accelerators). When set, the first device of the specified type is chosen as default device.</p>
<pre><code>AF_OPENCL_DEFAULT_DEVICE_TYPE=CPU ./myprogram
</code></pre>
<p>Note: <code>AF_OPENCL_DEFAULT_DEVICE</code> and <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.set_device.html">set_device</a> takes precedence over this variable.</p>
<h2><a class="header" href="#af_opencl_device_type" id="af_opencl_device_type">AF_OPENCL_DEVICE_TYPE</a></h2>
<p>Use this variable to only choose OpenCL devices of specified type. Valid values for this variable are:</p>
<ul>
<li>ALL: All OpenCL devices. (Default behavior).</li>
<li>CPU: CPU devices only.</li>
<li>GPU: GPU devices only.</li>
<li>ACC: Accelerator devices only.</li>
</ul>
<p>When set, the remaining OpenCL device types are ignored by the OpenCL backend.</p>
<pre><code>AF_OPENCL_DEVICE_TYPE=CPU ./myprogram
</code></pre>
<h2><a class="header" href="#af_opencl_cpu_offload" id="af_opencl_cpu_offload">AF_OPENCL_CPU_OFFLOAD</a></h2>
<p>When ArrayFire runs on devices with unified memory with the host (ie. <code>CL_DEVICE_HOST_UNIFIED_MENORY</code>
is true for the device) then certain functions are offloaded to run on the CPU using mapped buffers.</p>
<p>ArrayFire takes advantage of fast libraries such as MKL while spending no time copying memory from
device to host. The device memory is mapped to a host pointer which can be used in the offloaded
functions.</p>
<p>This functionality can be disabled by using the environment variable <code>AF_OPENCL_CPU_OFFLOAD=0</code>.</p>
<p>The default bevaior of this has changed in version 3.4. Prior to v3.4, CPU Offload functionality was
used only when the user set <code>AF_OPENCL_CPU_OFFLOAD=1</code> and disabled otherwise. From v3.4 onwards, CPU
Offload is enabled by default and is disabled only when <code>AF_OPENCL_CPU_OFFLOAD=0</code> is set.</p>
<h2><a class="header" href="#af_opencl_show_build_info" id="af_opencl_show_build_info">AF_OPENCL_SHOW_BUILD_INFO</a></h2>
<p>This variable is useful when debuggin OpenCL kernel compilation failures. When this variable is set
to 1, and an error occurs during a OpenCL kernel compilation, then the log and kernel are printed to screen.</p>
<h2><a class="header" href="#af_disable_graphics" id="af_disable_graphics">AF_DISABLE_GRAPHICS</a></h2>
<p>Setting this variable to 1 will disable window creation when graphics functions are being called.
Disabling window creation will disable all other graphics calls at runtime. This is a useful
when running code on servers and systems without displays. When graphics calls are run on such
machines, they will print warning about window creation failing. To suppress those calls, set this
variable.</p>
<h2><a class="header" href="#af_synchronous_calls" id="af_synchronous_calls">AF_SYNCHRONOUS_CALLS</a></h2>
<p>When this environment variable is set to 1, ArrayFire will execute all functions synchronously.</p>
<h2><a class="header" href="#af_show_load_path" id="af_show_load_path">AF_SHOW_LOAD_PATH</a></h2>
<p>When using the Unified backend, if this variable is set to 1, it will show the path where the ArrayFire
backend libraries are loaded from.</p>
<p>If the libraries are loaded from system paths, such as PATH or LD_LIBRARY_PATH etc, then it will
print &quot;system path&quot;. If the libraries are loaded from other paths, then those paths are shown in full.</p>
<h2><a class="header" href="#af_mem_debug" id="af_mem_debug">AF_MEM_DEBUG</a></h2>
<p>When AF_MEM_DEBUG is set to 1 (or anything not equal to 0), the caching mechanism in the memory manager
is disabled. The device buffers are allocated using native functions as needed and freed when going out
of scope. When the environment variable is not set, it is treated to be non zero.</p>
<pre><code>AF_MEM_DEBUG=1 ./myprogram
</code></pre>
<h2><a class="header" href="#af_max_buffers" id="af_max_buffers">AF_MAX_BUFFERS</a></h2>
<p>When AF_MAX_BUFFERS is set, this environment variable specifies the maximum number of buffers
allocated before garbage collection kicks in. Please note that the total number of buffers that
can exist simultaneously can be higher than this number. This variable tells the garbage collector
that it should free any available buffers immediately if the treshold is reached. When not set,
the default value is 1000.</p>
<h2><a class="header" href="#af_opencl_max_jit_len" id="af_opencl_max_jit_len">AF_OPENCL_MAX_JIT_LEN</a></h2>
<p>When set, this environment variable specifies the maximum height of the OpenCL JIT tree after
which evaluation is forced. The default value, as of v3.4, is 50 on OSX, 100 everywhere else.
This value was 20 for older versions.</p>
<h2><a class="header" href="#af_cuda_max_jit_len" id="af_cuda_max_jit_len">AF_CUDA_MAX_JIT_LEN</a></h2>
<p>When set, this environment variable specifies the maximum height of the CUDA JIT tree after
which evaluation is forced. The default value, as of v3.4, 100. This value was 20 for older versions.</p>
<h2><a class="header" href="#af_cpu_max_jit_len" id="af_cpu_max_jit_len">AF_CPU_MAX_JIT_LEN</a></h2>
<p>When set, this environment variable specifies the maximum length of the CPU JIT tree after
which evaluation is forced. The default value, as of v3.4, 100. This value was 20 for older versions.</p>
<h1><a class="header" href="#interoperability-with-cuda" id="interoperability-with-cuda">Interoperability with CUDA</a></h1>
<p>Although ArrayFire is quite extensive, there remain many cases in which you may want to write custom
kernels in CUDA or OpenCL. For example, you may wish to add ArrayFire to an existing code base to
increase your productivity, or you may need to supplement ArrayFire's functionality with your own
custom implementation of specific algorithms.</p>
<p>ArrayFire manages its own memory, runs within its own CUDA stream, and creates custom IDs for
devices. As such, most of the interoperability functions focus on reducing potential synchronization
conflicts between ArrayFire and CUDA.</p>
<h2><a class="header" href="#basics" id="basics">Basics</a></h2>
<p>It is fairly straightforward to interface ArrayFire with your own custom code. ArrayFire provides
several functions to ease this process including:</p>
<table><thead><tr><th>Function</th><th>Purpose</th></tr></thead><tbody>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.new_from_device_ptr">Array::new_from_device_ptr</a></td><td>Construct an ArrayFire <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a> from device memory</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.device_ptr">Array::device_ptr</a></td><td>Obtain a pointer to the device memory (implies <code>lock()</code>)</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.lock">Array::lock</a></td><td>Removes ArrayFire's control of a device memory pointer</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.unlock">Array::unlock</a></td><td>Restores ArrayFire's control over a device memory pointer</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.get_device.html">get_device</a></td><td>Gets the current ArrayFire device ID</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.set_device.html">set_device</a></td><td>Switches ArrayFire to the specified device</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_cuda_interop/fn.get_device_native_id.html">get_device_native_id</a></td><td>Fetches CUDA deviceID for a given ArrayFire device ID</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_cuda_interop/fn.set_device_native_id.html">set_device_native_id</a></td><td>Switches active device to the specified CUDA device ID</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_cuda_interop/fn.get_stream.html">get_stream</a></td><td>Get the current CUDA stream used by ArrayFire</td></tr>
</tbody></table>
<h2><a class="header" href="#using-custom-cuda-kernels-in-existing-arrayfire-application" id="using-custom-cuda-kernels-in-existing-arrayfire-application">Using custom CUDA kernels in existing ArrayFire application</a></h2>
<p>By default, ArrayFire manages its own memory and operates in its own CUDA stream. Thus there is a
slight amount of bookkeeping that needs to be done in order to integrate your custom CUDA kernel.</p>
<p>Ideally, we recommend using ArrayFire's CUDA stream to launch your custom kernels. However, this
is currently not possible due to limitation on <a href="https://github.com/bheisler/RustaCUDA">RustaCUDA</a> not being to able to wrap an
existing cudaStream_t/CUstream_t objects. The current work around is to create a stream of your
own and launch the kernel on it.</p>
<p>Notice that since ArrayFire and your kernels are not sharing the same CUDA stream, there is a need
to perform explicit synchronization before launching kernel on your stream that depends on the
computation carried out by ArrayFire earlier. This extra step is unnecessary once the above stated
limiation of RustaCUDA's stream is eliminated.</p>
<p>This process is best illustrated with a fully worked example:</p>
<pre><pre class="playpen"><code class="language-rust">use arrayfire as af;
use rustacuda::prelude::*;
use rustacuda::*;

use std::ffi::CString;

fn main() {
    // MAKE SURE to do all rustacuda initilization before arrayfire API's
    // first call. It seems like some CUDA context state is getting messed up
    // if we mix CUDA context init(device, context, module, stream) with ArrayFire API
    match rustacuda::init(CudaFlags::empty()) {
        Ok(()) =&gt; {}
        Err(e) =&gt; panic!(&quot;rustacuda init failure: {:?}&quot;, e),
    }
    let device = match Device::get_device(0) {
        Ok(d) =&gt; d,
        Err(e) =&gt; panic!(&quot;Failed to get device: {:?}&quot;, e),
    };
    let _context =
        match Context::create_and_push(ContextFlags::MAP_HOST | ContextFlags::SCHED_AUTO, device) {
            Ok(c) =&gt; c,
            Err(e) =&gt; panic!(&quot;Failed to create context: {:?}&quot;, e),
        };
    let ptx = CString::new(include_str!(&quot;./resources/add.ptx&quot;)).unwrap();
    let module = match Module::load_from_string(&amp;ptx) {
        Ok(m) =&gt; m,
        Err(e) =&gt; panic!(&quot;Failed to load module from string: {:?}&quot;, e),
    };
    let stream = match Stream::new(StreamFlags::NON_BLOCKING, None) {
        Ok(s) =&gt; s,
        Err(e) =&gt; panic!(&quot;Failed to create stream: {:?}&quot;, e),
    };

    af::set_device(0);
    af::info();

    let num: i32 = 10;
    let x = af::constant(1f32, af::dim4!(10));
    let y = af::constant(2f32, af::dim4!(10));
    let out = af::constant(0f32, af::dim4!(10));

    af::af_print!(&quot;x&quot;, x);
    af::af_print!(&quot;y&quot;, y);
    af::af_print!(&quot;out(init)&quot;, out);

    //TODO Figure out how to use Stream returned by ArrayFire with Rustacuda
    // let af_id = get_device();
    // let cuda_id = get_device_native_id(af_id);
    // let af_cuda_stream = get_stream(cuda_id);

    //TODO Figure out how to use Stream returned by ArrayFire with Rustacuda
    // let stream = Stream {inner: mem::transmute(af_cuda_stream)};

    // Run a custom CUDA kernel in the ArrayFire CUDA stream
    unsafe {
        // Obtain device pointers from ArrayFire using Array::device() method
        let d_x: *mut f32 = x.device_ptr() as *mut f32;
        let d_y: *mut f32 = y.device_ptr() as *mut f32;
        let d_o: *mut f32 = out.device_ptr() as *mut f32;

        match launch!(module.sum&lt;&lt;&lt;1, 1, 0, stream&gt;&gt;&gt;(
        memory::DevicePointer::wrap(d_x),
        memory::DevicePointer::wrap(d_y),
        memory::DevicePointer::wrap(d_o),
        num
        )) {
            Ok(()) =&gt; {}
            Err(e) =&gt; panic!(&quot;Kernel Launch failure: {:?}&quot;, e),
        }

        // wait for the kernel to finish as it is async call
        match stream.synchronize() {
            Ok(()) =&gt; {}
            Err(e) =&gt; panic!(&quot;Stream sync failure: {:?}&quot;, e),
        };

        // Return control of Array memory to ArrayFire using unlock
        x.unlock();
        y.unlock();
        out.unlock();
    }
    af::af_print!(&quot;sum after kernel launch&quot;, out);
}

</code></pre></pre>
<h2><a class="header" href="#adding-arrayfire-to-existing-cuda-application" id="adding-arrayfire-to-existing-cuda-application">Adding ArrayFire to existing CUDA Application</a></h2>
<p>Adding ArrayFire to an existing application is slightly more involved and can be somewhat tricky due
to several optimizations we implement. The most important are as follows:</p>
<ul>
<li>ArrayFire assumes control of all memory provided to it.</li>
<li>ArrayFire does not (in general) support in-place memory transactions.</li>
</ul>
<p>We will discuss the implications of these items below. To add ArrayFire to existing code you need to:</p>
<ol>
<li>Finish any pending CUDA operations (e.g. cudaDeviceSynchronize() or similar stream functions)</li>
<li>Create ArrayFire arrays from existing CUDA pointers</li>
<li>Perform operations on ArrayFire arrays</li>
<li>Instruct ArrayFire to finish operations using <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.eval">eval</a> and <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.sync.html">sync</a></li>
<li>Obtain pointers to important memory</li>
<li>Continue your CUDA application.</li>
<li>Free non-managed memory</li>
</ol>
<p>To create the <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a> fom device pointer, you should use one of the following approaches:</p>
<p>Using DeviceBuffer from <a href="https://github.com/bheisler/RustaCUDA">RustaCUDA</a>, or a Wrapper Object for CUDA device memory</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut buffer = memory::DeviceBuffer::from_slice(&amp;v).unwrap();

let array_dptr = Array::new_from_device_ptr(
    buffer.as_device_ptr().as_raw_mut(), dim4!(10, 10));

array_dptr.lock(); // Needed to avoid free as arrayfire takes ownership
#}</code></pre></pre>
<p>Using raw pointer returned from cuda_malloc interface exposed by <a href="https://github.com/bheisler/RustaCUDA">RustaCUDA</a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut dptr: *mut f32 = std::ptr::null_mut();
unsafe {
    dptr = memory::cuda_malloc::&lt;f32&gt;(10*10).unwrap().as_raw_mut();
}

let array_dptr = Array::new_from_device_ptr(dptr, dim4!(10, 10));
// After ArrayFire takes over ownership of the pointer, you can use other
// arrayfire functions as usual.
#}</code></pre></pre>
<p>ArrayFire's memory manager automatically assumes responsibility for any memory provided to it.
Thus ArrayFire could free or reuse the memory at any later time. If this behavior is not desired,
you may call <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.unlock">Array::unlock</a> and manage the memory yourself. However, if you do so, please be
cautious not to free memory when ArrayFire might be using it!</p>
<p>The seven steps above are best illustrated using a fully-worked example:</p>
<pre><pre class="playpen"><code class="language-rust">use arrayfire::{af_print, dim4, info, set_device, Array};
use rustacuda::prelude::*;

fn main() {
    // MAKE SURE to do all rustacuda initilization before arrayfire API's
    // first call. It seems like some CUDA context state is getting messed up
    // if we mix CUDA context init(device, context, module, stream) with ArrayFire API
    match rustacuda::init(CudaFlags::empty()) {
        Ok(()) =&gt; {}
        Err(e) =&gt; panic!(&quot;rustacuda init failure: {:?}&quot;, e),
    }
    let device = match Device::get_device(0) {
        Ok(d) =&gt; d,
        Err(e) =&gt; panic!(&quot;Failed to get device: {:?}&quot;, e),
    };
    let _context =
        match Context::create_and_push(ContextFlags::MAP_HOST | ContextFlags::SCHED_AUTO, device) {
            Ok(c) =&gt; c,
            Err(e) =&gt; panic!(&quot;Failed to create context: {:?}&quot;, e),
        };
    let stream = match Stream::new(StreamFlags::NON_BLOCKING, None) {
        Ok(s) =&gt; s,
        Err(e) =&gt; panic!(&quot;Failed to create stream: {:?}&quot;, e),
    };

    let mut in_x = DeviceBuffer::from_slice(&amp;[1.0f32; 10]).unwrap();
    let mut in_y = DeviceBuffer::from_slice(&amp;[2.0f32; 10]).unwrap();

    // wait for any prior kernels to finish before passing
    // the device pointers to ArrayFire
    match stream.synchronize() {
        Ok(()) =&gt; {}
        Err(e) =&gt; panic!(&quot;Stream sync failure: {:?}&quot;, e),
    };

    set_device(0);
    info();

    let x = Array::new_from_device_ptr(in_x.as_device_ptr().as_raw_mut(), dim4!(10));
    let y = Array::new_from_device_ptr(in_y.as_device_ptr().as_raw_mut(), dim4!(10));

    // Lock so that ArrayFire doesn't free pointers from RustaCUDA
    // But we have to make sure these pointers stay in valid scope
    // as long as the associated ArrayFire Array objects are valid
    x.lock();
    y.lock();

    af_print!(&quot;x&quot;, x);
    af_print!(&quot;y&quot;, y);

    let o = x + y;
    af_print!(&quot;out&quot;, o);

    let _o_dptr = unsafe { o.device_ptr() }; // Calls an implicit lock

    // User has to call unlock if they want to relenquish control to ArrayFire

    // Once the non-arrayfire operations are done, call unlock.
    o.unlock(); // After this, there is no guarantee that value of o_dptr is valid
}

</code></pre></pre>
<h1><a class="header" href="#interoperability-with-opencl" id="interoperability-with-opencl">Interoperability with OpenCL</a></h1>
<p>Although ArrayFire is quite extensive, there remain many cases in which you may want to write custom
kernels in CUDA or OpenCL. For example, you may wish to add ArrayFire to an existing code base to
increase your productivity, or you may need to supplement ArrayFire's functionality with your own
custom implementation of specific algorithms.</p>
<p>ArrayFire manages its own context, queue, memory, and creates custom IDs for devices. As such, most
of the interoperability functions focus on reducing potential synchronization conflicts between
ArrayFire and OpenCL.</p>
<h2><a class="header" href="#basics-1" id="basics-1">Basics</a></h2>
<p>It is fairly straightforward to interface ArrayFire with your own custom code. ArrayFire provides
several functions to ease this process including:</p>
<table><thead><tr><th>Function</th><th>Purpose</th></tr></thead><tbody>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.new_from_device_ptr">Array::new_from_device_ptr</a></td><td>Construct an ArrayFire Array from cl_mem</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.device_ptr">Array::device_ptr</a></td><td>Obtain a pointer to the device memory (implies <code>lock</code>)</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.lock">Array::lock</a></td><td>Removes ArrayFire's control of a device memory pointer</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.unlock">Array::unlock</a></td><td>Restores ArrayFire's control over a device memory pointer</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_opencl_interop/fn.get_platform.html">get_platform</a></td><td>Get ArrayFire's current cl_platform</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.get_device.html">get_device</a></td><td>Gets the current ArrayFire device ID</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_opencl_interop/fn.get_device_id.html">get_device_id</a></td><td>Get ArrayFire's current cl_device_id</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_opencl_interop/fn.set_device_id.html">set_device_id</a></td><td>Set ArrayFire's device from a cl_device_id</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.set_device.html">set_device</a></td><td>Switches ArrayFire to the specified device</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_opencl_interop/fn.get_context.html">get_context</a></td><td>Get ArrayFire's current cl_context</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_opencl_interop/fn.get_queue.html">get_queue</a></td><td>Get ArrayFire's current cl_command_queue</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_opencl_interop/fn.get_device_type.html">get_device_type</a></td><td>Get the current <a href="http://arrayfire.org/arrayfire-rust/af_opencl_interop/enum.DeviceType.html">DeviceType</a></td></tr>
</tbody></table>
<p>Note that the pointer returned by <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.device_ptr">Array::device_ptr</a> should be cast to <code>cl_mem</code> before using
it with OpenCL opaque types. The pointer is a <code>cl_mem</code> internally that is force casted to pointer
type by ArrayFire before returning the value to caller.</p>
<p>Additionally, the OpenCL backend permits the programmer to add and remove custom devices from the
ArrayFire device manager. These permit you to attach ArrayFire directly to the OpenCL queue used by
other portions of your application.</p>
<table><thead><tr><th>Function</th><th>Purpose</th></tr></thead><tbody>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_opencl_interop/fn.add_device_context.html">add_device_context</a></td><td>Add a new device to ArrayFire's device manager</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_opencl_interop/fn.set_device_context.html">set_device_context</a></td><td>Set ArrayFire's device from cl_device_id &amp; cl_context</td></tr>
<tr><td><a href="http://arrayfire.org/arrayfire-rust/af_opencl_interop/fn.delete_device_context.html">delete_device_context</a></td><td>Remove a device from ArrayFire's device manager</td></tr>
</tbody></table>
<p>Below we provide two worked examples on how ArrayFire can be integrated
into new and existing projects.</p>
<h2><a class="header" href="#adding-custom-opencl-kernels-to-an-existing-arrayfire-application" id="adding-custom-opencl-kernels-to-an-existing-arrayfire-application">Adding custom OpenCL kernels to an existing ArrayFire application</a></h2>
<p>By default, ArrayFire manages its own context, queue, memory, and creates custom IDs for devices.
Thus there is some bookkeeping that needs to be done to integrate your custom OpenCL kernel.</p>
<p>If your kernels can share operate in the same queue as ArrayFire, you should:</p>
<ol>
<li>Obtain the OpenCL context, device, and queue used by ArrayFire</li>
<li>Obtain cl_mem references to <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a> objects</li>
<li>Load, build, and use your kernels</li>
<li>Return control of <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a> memory to ArrayFire</li>
</ol>
<p>Note, ArrayFire uses an in-order queue, thus when ArrayFire and your kernels are operating in the
same queue, there is no need to perform any synchronization operations.</p>
<p>This process is best illustrated with a fully worked example:</p>
<pre><pre class="playpen"><code class="language-rust">//! A trivial example. Copied from ocl-core crate repository.
use af_opencl_interop as afcl;
use arrayfire as af;

use ocl_core::{ArgVal, Event};

use std::ffi::CString;

fn main() {
    af::info();
    let dims = af::dim4!(8);
    let af_buffer = af::constant(0f32, dims.clone());
    af::af_print!(&quot;af_buffer&quot;, af_buffer);

    let src = r#&quot;
        __kernel void add(__global float* buffer, float scalar) {
            buffer[get_global_id(0)] += scalar;
        }
    &quot;#;

    let af_did = afcl::get_device_id();
    let af_ctx = afcl::get_context(false);
    let af_que = afcl::get_queue(false);

    let _devid = unsafe { ocl_core::DeviceId::from_raw(af_did) };
    let contx = unsafe { ocl_core::Context::from_raw_copied_ptr(af_ctx) };
    let queue = unsafe { ocl_core::CommandQueue::from_raw_copied_ptr(af_que) };

    // Define which platform and device(s) to use. Create a context,
    // queue, and program then define some dims..
    let src_cstring = CString::new(src).unwrap();
    let program = ocl_core::create_program_with_source(&amp;contx, &amp;[src_cstring]).unwrap();
    ocl_core::build_program(
        &amp;program,
        None::&lt;&amp;[()]&gt;,
        &amp;CString::new(&quot;&quot;).unwrap(),
        None,
        None,
    )
    .unwrap();

    // Fetch cl_mem from ArrayFire Array
    let ptr = unsafe { af_buffer.device_ptr() };
    let buffer = unsafe { ocl_core::Mem::from_raw_copied_ptr(ptr) };

    // Create a kernel with arguments matching those in the source above:
    let kernel = ocl_core::create_kernel(&amp;program, &quot;add&quot;).unwrap();
    ocl_core::set_kernel_arg(&amp;kernel, 0, ArgVal::mem(&amp;buffer)).unwrap();
    ocl_core::set_kernel_arg(&amp;kernel, 1, ArgVal::scalar(&amp;10.0f32)).unwrap();

    let ocl_dims: [usize; 3] = [dims[0] as usize, dims[1] as usize, dims[2] as usize];
    unsafe {
        ocl_core::enqueue_kernel(
            &amp;queue,
            &amp;kernel,
            1,
            None,
            &amp;ocl_dims,
            None,
            None::&lt;Event&gt;,
            None::&lt;&amp;mut Event&gt;,
        )
        .unwrap();
    }
    ocl_core::finish(&amp;queue).unwrap();
    af_buffer.unlock(); //Give back control of cl_mem to ArrayFire memory manager

    af::af_print!(&quot;af_buffer after running Custom Kernel on it&quot;, af_buffer);
}

</code></pre></pre>
<p>If your kernels needs to operate in their own OpenCL queue, the process is essentially identical,
except you need to instruct ArrayFire to complete its computations using the <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.sync.html">sync</a> function
prior to launching your own kernel and ensure your kernels are complete using <code>clFinish</code>
(or similar) commands prior to returning control of the memory to ArrayFire:</p>
<ol>
<li>Obtain the OpenCL context, device, and queue used by ArrayFire</li>
<li>Obtain cl_mem references to <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a> objects</li>
<li>Instruct ArrayFire to finish operations using <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.sync.html">sync</a></li>
<li>Load, build, and use your kernels</li>
<li>Instruct OpenCL to finish operations using clFinish() or similar commands.</li>
<li>Return control of <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a> memory to ArrayFire</li>
</ol>
<h2><a class="header" href="#adding-arrayfire-to-an-existing-opencl-application" id="adding-arrayfire-to-an-existing-opencl-application">Adding ArrayFire to an existing OpenCL application</a></h2>
<p>Adding ArrayFire to an existing application is slightly more involved and can be somewhat tricky due
to several optimizations we implement. The most important are as follows:</p>
<ul>
<li>ArrayFire assumes control of all memory provided to it.</li>
<li>ArrayFire does not (in general) support in-place memory transactions.</li>
</ul>
<p>We will discuss the implications of these items below. To add ArrayFire to existing code you need to:</p>
<ol>
<li>Instruct OpenCL to complete its operations using clFinish (or similar)</li>
<li>Instruct ArrayFire to use the user-created OpenCL Context</li>
<li>Create ArrayFire arrays from OpenCL memory objects</li>
<li>Perform ArrayFire operations on the <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html">Array</a>s</li>
<li>Instruct ArrayFire to finish operations using <a href="http://arrayfire.org/arrayfire-rust/arrayfire/fn.sync.html">sync</a></li>
<li>Obtain cl_mem references for important memory</li>
<li>Continue your OpenCL application</li>
</ol>
<!--
To create the [Array][18] object, you should use the following approach:

```rust
```
-->
<blockquote>
<p>ArrayFire's memory manager automatically assumes responsibility for any memory provided to
it. If you are creating an array from another RAII style object, you should retain it to ensure
your memory is not deallocated if your RAII object were to go out of scope.</p>
</blockquote>
<blockquote>
<p>If you do not wish for ArrayFire to manage your memory, you may call the <a href="http://arrayfire.org/arrayfire-rust/arrayfire/struct.Array.html#method.unlock">Array::unlock</a>
function and manage the memory yourself; however, if you do so, please be cautious not to call
<code>clReleaseMemObj</code> on a <code>cl_mem</code>  when ArrayFire might be using it!</p>
</blockquote>
<p>Given below is a fully working example:</p>
<pre><pre class="playpen"><code class="language-rust">//! A trivial example. Copied from ocl-core crate repository.
use af_opencl_interop as afcl;
use arrayfire as af;

use ocl_core::{ContextProperties, Event};

fn main() {
    // Choose platform &amp; device(s) to use. Create a context, queue,
    let platform_id = ocl_core::default_platform().unwrap();
    let device_ids = ocl_core::get_device_ids(&amp;platform_id, None, None).unwrap();
    let device_id = device_ids[0];
    let context_properties = ContextProperties::new().platform(platform_id);
    let context =
        ocl_core::create_context(Some(&amp;context_properties), &amp;[device_id], None, None).unwrap();
    let queue = ocl_core::create_command_queue(&amp;context, &amp;device_id, None).unwrap();
    let dims = [8, 1, 1];

    // Create a `Buffer`:
    let mut vec = vec![0.0f32; dims[0]];
    let buffer = unsafe {
        ocl_core::create_buffer(
            &amp;context,
            ocl_core::MEM_READ_WRITE | ocl_core::MEM_COPY_HOST_PTR,
            dims[0],
            Some(&amp;vec),
        )
        .unwrap()
    };
    ocl_core::finish(&amp;queue).unwrap(); //sync up before switching to arrayfire

    // Add custom device, context and associated queue to ArrayFire
    afcl::add_device_context(device_id.as_raw(), context.as_ptr(), queue.as_ptr());
    afcl::set_device_context(device_id.as_raw(), context.as_ptr());
    af::info();

    let mut af_buffer = af::Array::new_from_device_ptr(
        buffer.as_ptr() as *mut f32,
        af::Dim4::new(&amp;[dims[0] as u64, 1, 1, 1]),
    );

    af::af_print!(&quot;GPU Buffer before modification:&quot;, af_buffer);

    af_buffer = af_buffer + 10f32;

    af::sync(af::get_device());
    unsafe {
        let ptr = af_buffer.device_ptr();
        let obuf = ocl_core::Mem::from_raw_copied_ptr(ptr);

        // Read results from the device into a vector:
        ocl_core::enqueue_read_buffer(
            &amp;queue,
            &amp;obuf,
            true,
            0,
            &amp;mut vec,
            None::&lt;Event&gt;,
            None::&lt;&amp;mut Event&gt;,
        )
        .unwrap();
    }
    println!(&quot;GPU buffer on host after ArrayFire operation: {:?}&quot;, vec);

    // Remove device from ArrayFire management towards Application Exit
    af::set_device(0); // Cannot pop when in Use, hence switch to another device
    afcl::delete_device_context(device_id.as_raw(), context.as_ptr());
}

</code></pre></pre>
<h1><a class="header" href="#arrayfire-in-threaded-applications" id="arrayfire-in-threaded-applications">ArrayFire in Threaded Applications</a></h1>
<p>In this chapter, we will looking at how to use ArrayFire in multi-threaded programs. We shall
go over the details in the following order.</p>
<ul>
<li><a href="multi-threading.html#move-an-array-to-thread">Move an Array to thread</a></li>
<li><a href="multi-threading.html#read-array-from-multiple-threads">Read Array from Multiple threads</a></li>
<li><a href="multi-threading.html#write-to-array-from-multiple-threads">Write to Array from Multiple threads</a></li>
<li><a href="multi-threading.html#write-to-single-array-using-channel">Write to single Array using Channel</a></li>
</ul>
<h2><a class="header" href="#move-an-array-to-thread" id="move-an-array-to-thread">Move an Array to thread</a></h2>
<p>In this section, we are going to create an Array on main thread and move it to a child thread,
modify it and then print it from the child thread.</p>
<pre><code class="language-rust noplaypen">        set_device(0);
        info();
        let mut a = constant(1, dim4!(3, 3));

        let handle = thread::spawn(move || {
            //set_device to appropriate device id is required in each thread
            set_device(0);

            println!(&quot;\nFrom thread {:?}&quot;, thread::current().id());

            a += constant(2, dim4!(3, 3));
            print(&amp;a);
        });

        //Need to join other threads as main thread holds arrayfire context
        handle.join().unwrap();
</code></pre>
<h2><a class="header" href="#read-array-from-multiple-threads" id="read-array-from-multiple-threads">Read Array from Multiple threads</a></h2>
<p>Now, let's expand the earlier example to do a bunch of arithmetic operations in parallel on
multiple threads using the same Array objects.</p>
<pre><code class="language-rust noplaypen">        let ops: Vec&lt;_&gt; = vec![Op::Add, Op::Sub, Op::Div, Op::Mul, Op::Add, Op::Div];

        // Set active GPU/device on main thread on which
        // subsequent Array objects are created
        set_device(0);

        // ArrayFire Array's are internally maintained via atomic reference counting
        // Thus, they need no Arc wrapping while moving to another thread.
        // Just call clone method on the object and share the resulting clone object
        let a = constant(1.0f32, dim4!(3, 3));
        let b = constant(2.0f32, dim4!(3, 3));

        let threads: Vec&lt;_&gt; = ops
            .into_iter()
            .map(|op| {
                let x = a.clone();
                let y = b.clone();
                thread::spawn(move || {
                    set_device(0); //Both of objects are created on device 0 earlier
                    match op {
                        Op::Add =&gt; {
                            let _c = x + y;
                        }
                        Op::Sub =&gt; {
                            let _c = x - y;
                        }
                        Op::Div =&gt; {
                            let _c = x / y;
                        }
                        Op::Mul =&gt; {
                            let _c = x * y;
                        }
                    }
                    sync(0);
                    thread::sleep(std::time::Duration::new(1, 0));
                })
            })
            .collect();
        for child in threads {
            let _ = child.join();
        }
</code></pre>
<p>Given below is the definition of the enum <code>Op</code> we used in the example for illustration simplicity.</p>
<pre><code class="language-rust noplaypen">    #[derive(Debug, Copy, Clone)]
    enum Op {
        Add,
        Sub,
        Div,
        Mul,
    }
</code></pre>
<h2><a class="header" href="#write-to-array-from-multiple-threads" id="write-to-array-from-multiple-threads">Write to Array from Multiple threads</a></h2>
<p>Let us further expand the earlier example by accumulating the results of the arithmetic operations
into a single Array object.</p>
<p>The code will differ from earlier section in couple of locations:</p>
<ul>
<li>In the main thread, we wrap the accumulating Array in a read-write lock (<code>std::sync::RwLock</code>)
which is in turn wrapped in an atomically reference counted counter a.k.a <code>std::sync::Arc</code>.</li>
<li>In the children threads, we use the guarded objects returned by RwLock's write method to access
the accumulator Array.</li>
</ul>
<pre><code class="language-rust noplaypen">        let ops: Vec&lt;_&gt; = vec![Op::Add, Op::Sub, Op::Div, Op::Mul, Op::Add, Op::Div];

        // Set active GPU/device on main thread on which
        // subsequent Array objects are created
        set_device(0);

        let c = constant(0.0f32, dim4!(3, 3));
        let a = constant(1.0f32, dim4!(3, 3));
        let b = constant(2.0f32, dim4!(3, 3));

        // Move ownership to RwLock and wrap in Arc since same object is to be modified
        let c_lock = Arc::new(RwLock::new(c));

        // a and b are internally reference counted by ArrayFire. Unless there
        // is prior known need that they may be modified, you can simply clone
        // the objects pass them to threads

        let threads: Vec&lt;_&gt; = ops
            .into_iter()
            .map(|op| {
                let x = a.clone();
                let y = b.clone();

                let wlock = c_lock.clone();
                thread::spawn(move || {
                    //Both of objects are created on device 0 in main thread
                    //Every thread needs to set the device that it is going to
                    //work on. Note that all Array objects must have been created
                    //on same device as of date this is written on.
                    set_device(0);
                    if let Ok(mut c_guard) = wlock.write() {
                        match op {
                            Op::Add =&gt; {
                                *c_guard += x + y;
                            }
                            Op::Sub =&gt; {
                                *c_guard += x - y;
                            }
                            Op::Div =&gt; {
                                *c_guard += x / y;
                            }
                            Op::Mul =&gt; {
                                *c_guard += x * y;
                            }
                        }
                    }
                })
            })
            .collect();

        for child in threads {
            let _ = child.join();
        }

        //let read_guard = c_lock.read().unwrap();
        //af_print!(&quot;C after threads joined&quot;, *read_guard);
        //C after threads joined
        //[3 3 1 1]
        //    8.0000     8.0000     8.0000
        //    8.0000     8.0000     8.0000
        //    8.0000     8.0000     8.0000
</code></pre>
<h2><a class="header" href="#write-to-single-array-using-channel" id="write-to-single-array-using-channel">Write to single Array using Channel</a></h2>
<p>In this section, we shall modify the example to use channel instead of data sharing.</p>
<pre><code class="language-rust noplaypen">        let ops: Vec&lt;_&gt; = vec![Op::Add, Op::Sub, Op::Div, Op::Mul, Op::Add, Op::Div];
        let ops_len: usize = ops.len();

        // Set active GPU/device on main thread on which
        // subsequent Array objects are created
        set_device(0);

        let mut c = constant(0.0f32, dim4!(3, 3));
        let a = constant(1.0f32, dim4!(3, 3));
        let b = constant(2.0f32, dim4!(3, 3));

        let (tx, rx) = mpsc::channel();

        let threads: Vec&lt;_&gt; = ops
            .into_iter()
            .map(|op| {
                // a and b are internally reference counted by ArrayFire. Unless there
                // is prior known need that they may be modified, you can simply clone
                // the objects pass them to threads
                let x = a.clone();
                let y = b.clone();

                let tx_clone = tx.clone();

                thread::spawn(move || {
                    //Both of objects are created on device 0 in main thread
                    //Every thread needs to set the device that it is going to
                    //work on. Note that all Array objects must have been created
                    //on same device as of date this is written on.
                    set_device(0);

                    let c = match op {
                        Op::Add =&gt; x + y,
                        Op::Sub =&gt; x - y,
                        Op::Div =&gt; x / y,
                        Op::Mul =&gt; x * y,
                    };
                    tx_clone.send(c).unwrap();
                })
            })
            .collect();

        for _i in 0..ops_len {
            c += rx.recv().unwrap();
        }

        //Need to join other threads as main thread holds arrayfire context
        for child in threads {
            let _ = child.join();
        }

        //af_print!(&quot;C after accumulating results&quot;, &amp;c);
        //[3 3 1 1]
        //    8.0000     8.0000     8.0000
        //    8.0000     8.0000     8.0000
        //    8.0000     8.0000     8.0000
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
